use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// Compaction Types
// ============================================================================

/// Metadata from a compaction event
#[derive(Debug, Clone, Serialize, Deserialize)]
#[allow(dead_code)]
pub struct CompactMetadata {
    /// How compaction was triggered
    pub trigger: String, // "manual" or "auto"
    /// Token count before compaction
    pub pre_tokens: u64,
}

// ============================================================================
// Usage Types
// ============================================================================

/// Token usage data from Claude CLI response
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UsageData {
    /// Input tokens (context sent to Claude)
    pub input_tokens: u64,
    /// Output tokens (generated by Claude)
    pub output_tokens: u64,
    /// Cache read tokens (reused from previous requests, cost reduction)
    #[serde(default)]
    pub cache_read_input_tokens: u64,
    /// Cache creation tokens (cached for future requests)
    #[serde(default)]
    pub cache_creation_input_tokens: u64,
}

// ============================================================================
// Message Types
// ============================================================================

/// Role of a chat message sender
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    User,
    Assistant,
}

/// Thinking level for Claude responses
/// Controls --settings alwaysThinkingEnabled and MAX_THINKING_TOKENS env var
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Default)]
#[serde(rename_all = "lowercase")]
pub enum ThinkingLevel {
    Off,
    Think,
    Megathink,
    #[default]
    Ultrathink,
}

impl ThinkingLevel {
    /// Whether thinking is enabled for this level
    pub fn is_enabled(&self) -> bool {
        !matches!(self, ThinkingLevel::Off)
    }

    /// Get the MAX_THINKING_TOKENS value for this level
    pub fn thinking_tokens(&self) -> Option<u32> {
        match self {
            ThinkingLevel::Off => None,
            ThinkingLevel::Think => Some(4_000),
            ThinkingLevel::Megathink => Some(10_000),
            ThinkingLevel::Ultrathink => Some(31_999),
        }
    }
}

/// A tool call made by Claude during a response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCall {
    /// Tool call ID from Claude
    pub id: String,
    /// Name of the tool (e.g., "Read", "Edit", "Bash")
    pub name: String,
    /// Input parameters as JSON value
    pub input: serde_json::Value,
    /// Output/result from tool execution (from tool_result messages)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub output: Option<String>,
    /// Parent tool use ID for sub-agent tool calls (for parallel task attribution)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent_tool_use_id: Option<String>,
}

/// A permission denial from Claude CLI when a tool requires approval
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PermissionDenial {
    /// Name of the denied tool (e.g., "Bash")
    pub tool_name: String,
    /// Tool use ID from Claude
    pub tool_use_id: String,
    /// Input parameters that were denied
    pub tool_input: serde_json::Value,
}

/// Context for a denied message that can be re-sent after permission approval
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeniedMessageContext {
    /// Original message content
    pub message: String,
    /// Model that was selected
    pub model: String,
    /// Thinking level that was selected
    pub thinking_level: String,
}

/// A content block in a message - text, tool use, or thinking
/// Used to preserve the order of content in Claude's response
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentBlock {
    Text { text: String },
    ToolUse { tool_call_id: String },
    Thinking { thinking: String },
}

/// A single chat message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMessage {
    pub id: String,
    /// Session ID this message belongs to (was worktree_id in v1)
    #[serde(alias = "worktree_id")]
    pub session_id: String,
    pub role: MessageRole,
    pub content: String,
    pub timestamp: u64,
    /// Tool calls made during this message (only for assistant messages)
    #[serde(default)]
    pub tool_calls: Vec<ToolCall>,
    /// Ordered content blocks preserving tool position in response (optional for backward compat)
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub content_blocks: Vec<ContentBlock>,
    /// True if the message was cancelled mid-stream
    #[serde(default)]
    pub cancelled: bool,
    /// True if the plan in this message was approved by the user
    #[serde(default)]
    pub plan_approved: bool,
    /// Model used when this message was sent (user messages only)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,
    /// Execution mode when this message was sent (user messages only)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execution_mode: Option<String>,
    /// Thinking level when this message was sent (user messages only)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thinking_level: Option<String>,
    /// True if this message was recovered from a crash
    #[serde(default)]
    pub recovered: bool,
    /// Token usage for this message (assistant messages only)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<UsageData>,
}

impl Default for ChatMessage {
    fn default() -> Self {
        Self {
            id: String::new(),
            session_id: String::new(),
            role: MessageRole::User,
            content: String::new(),
            timestamp: 0,
            tool_calls: vec![],
            content_blocks: vec![],
            cancelled: false,
            plan_approved: false,
            model: None,
            execution_mode: None,
            thinking_level: None,
            recovered: false,
            usage: None,
        }
    }
}

/// Context passed to Claude CLI (extensible for future additions)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClaudeContext {
    pub worktree_path: String,
    // Future: pub additional_files: Vec<String>,
    // Future: pub custom_instructions: Option<String>,
}

impl ClaudeContext {
    pub fn new(worktree_path: String) -> Self {
        Self { worktree_path }
    }
}

// ============================================================================
// Image Types (for pasted images in chat)
// ============================================================================

/// Response from saving a pasted image
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SaveImageResponse {
    /// Unique ID for this image
    pub id: String,
    /// Filename (e.g., "image-1704067200-abc123.png")
    pub filename: String,
    /// Full path to the saved image
    pub path: String,
}

/// Response from saving a pasted text file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SaveTextResponse {
    /// Unique ID for this text file
    pub id: String,
    /// Filename (e.g., "paste-1704067200-abc123.txt")
    pub filename: String,
    /// Full path to the saved text file
    pub path: String,
    /// Size in bytes
    pub size: usize,
}

/// Response from reading a pasted text file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadTextResponse {
    /// Content of the text file
    pub content: String,
    /// Size in bytes
    pub size: usize,
}

// ============================================================================
// Session Types (for multiple tabs per worktree)
// ============================================================================

/// A chat session within a worktree (supports multiple sessions per worktree)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Session {
    /// Unique session identifier (UUID v4)
    pub id: String,
    /// Display name ("Session 1", or user-customized name)
    pub name: String,
    /// Order index for tab ordering (0-indexed)
    pub order: u32,
    /// Unix timestamp when session was created
    pub created_at: u64,
    /// Chat messages for this session
    #[serde(default)]
    pub messages: Vec<ChatMessage>,
    /// Message count (populated separately for efficiency when full messages not needed)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message_count: Option<u32>,
    /// Claude CLI session ID for resuming conversations
    #[serde(default)]
    pub claude_session_id: Option<String>,
    /// Selected model for this session
    #[serde(default)]
    pub selected_model: Option<String>,
    /// Selected thinking level for this session
    #[serde(default)]
    pub selected_thinking_level: Option<ThinkingLevel>,
    /// Whether session naming has been attempted for this session
    /// Prevents re-triggering on app restart
    #[serde(default)]
    pub session_naming_completed: bool,
    /// Unix timestamp when session was archived (None = not archived)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived_at: Option<u64>,

    // ========================================================================
    // Session-specific UI state (moved from ui-state.json)
    // ========================================================================
    /// Tool call IDs that have been answered (for AskUserQuestion)
    #[serde(default)]
    pub answered_questions: Vec<String>,
    /// Submitted answers per tool call: toolCallId -> answers (as JSON)
    #[serde(default)]
    pub submitted_answers: HashMap<String, serde_json::Value>,
    /// Finding keys that have been marked as fixed
    #[serde(default)]
    pub fixed_findings: Vec<String>,
    /// Pending permission denials awaiting user approval
    #[serde(default)]
    pub pending_permission_denials: Vec<PermissionDenial>,
    /// Original message context for re-send after permission approval
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub denied_message_context: Option<DeniedMessageContext>,
    /// Whether this session is marked for review in session board
    #[serde(default)]
    pub is_reviewing: bool,
    /// Whether this session is waiting for user input (AskUserQuestion, ExitPlanMode)
    #[serde(default)]
    pub waiting_for_input: bool,
    /// Message IDs whose plans have been approved (for NDJSON-only storage)
    #[serde(default)]
    pub approved_plan_message_ids: Vec<String>,
}

impl Session {
    /// Create a new session with the given name
    pub fn new(name: String, order: u32) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name,
            order,
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            messages: vec![],
            message_count: None,
            claude_session_id: None,
            selected_model: None,
            selected_thinking_level: None,
            session_naming_completed: false,
            archived_at: None,
            // Session-specific UI state
            answered_questions: vec![],
            submitted_answers: HashMap::new(),
            fixed_findings: vec![],
            pending_permission_denials: vec![],
            denied_message_context: None,
            is_reviewing: false,
            waiting_for_input: false,
            approved_plan_message_ids: vec![],
        }
    }

    /// Create a default "Session 1" session
    pub fn default_session() -> Self {
        Self::new("Session 1".to_string(), 0)
    }
}

/// Lightweight session entry for index files (fast tab rendering)
/// Stored in sessions/index/{worktree_id}.json
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionIndexEntry {
    /// Unique session identifier (UUID v4)
    pub id: String,
    /// Display name ("Session 1", or user-customized name)
    pub name: String,
    /// Order index for tab ordering (0-indexed)
    pub order: u32,
    /// Message count (for badge display)
    #[serde(default)]
    pub message_count: u32,
    /// Unix timestamp when session was archived (None = not archived)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived_at: Option<u64>,
}

/// Worktree index - lightweight data for tab bar rendering
/// Stored in sessions/index/{worktree_id}.json
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorktreeIndex {
    /// Worktree ID for reference
    pub worktree_id: String,
    /// ID of the active/displayed session tab
    #[serde(default)]
    pub active_session_id: Option<String>,
    /// Lightweight session entries for tab rendering
    pub sessions: Vec<SessionIndexEntry>,
    /// Storage format version for migrations
    #[serde(default = "default_version")]
    pub version: u32,
    /// Whether branch naming has been attempted for this worktree
    /// Prevents re-triggering on app restart
    #[serde(default)]
    pub branch_naming_completed: bool,
}

impl Default for WorktreeIndex {
    fn default() -> Self {
        let session_id = uuid::Uuid::new_v4().to_string();
        Self {
            worktree_id: String::new(),
            active_session_id: Some(session_id.clone()),
            sessions: vec![SessionIndexEntry {
                id: session_id,
                name: "Session 1".to_string(),
                order: 0,
                message_count: 0,
                archived_at: None,
            }],
            version: 1,
            branch_naming_completed: false,
        }
    }
}

impl WorktreeIndex {
    /// Create new WorktreeIndex for a worktree with one default session
    pub fn new(worktree_id: String) -> Self {
        let session_id = uuid::Uuid::new_v4().to_string();
        Self {
            worktree_id,
            active_session_id: Some(session_id.clone()),
            sessions: vec![SessionIndexEntry {
                id: session_id,
                name: "Session 1".to_string(),
                order: 0,
                message_count: 0,
                archived_at: None,
            }],
            version: 1,
            branch_naming_completed: false,
        }
    }

    /// Find a session entry by ID (used in tests)
    #[cfg(test)]
    pub fn find_session(&self, session_id: &str) -> Option<&SessionIndexEntry> {
        self.sessions.iter().find(|s| s.id == session_id)
    }

    /// Find a session entry by ID (mutable)
    pub fn find_session_mut(&mut self, session_id: &str) -> Option<&mut SessionIndexEntry> {
        self.sessions.iter_mut().find(|s| s.id == session_id)
    }

    /// Get the next session number for naming (used in tests)
    #[cfg(test)]
    pub fn next_session_number(&self) -> u32 {
        self.sessions.len() as u32 + 1
    }
}

fn default_version() -> u32 {
    1
}

impl SessionMetadata {
    /// Convert metadata to a Session API response struct (with empty messages)
    /// Messages should be loaded separately via load_session_messages() and set on the returned Session
    pub fn to_session(&self) -> Session {
        Session {
            id: self.id.clone(),
            name: self.name.clone(),
            order: self.order,
            created_at: self.created_at,
            messages: vec![], // Loaded separately from JSONL files
            message_count: Some(self.to_index_entry().message_count),
            claude_session_id: self.claude_session_id.clone(),
            selected_model: self.selected_model.clone(),
            selected_thinking_level: self.selected_thinking_level.clone(),
            session_naming_completed: self.session_naming_completed,
            archived_at: self.archived_at,
            answered_questions: self.answered_questions.clone(),
            submitted_answers: self.submitted_answers.clone(),
            fixed_findings: self.fixed_findings.clone(),
            pending_permission_denials: self.pending_permission_denials.clone(),
            denied_message_context: self.denied_message_context.clone(),
            is_reviewing: self.is_reviewing,
            waiting_for_input: self.waiting_for_input,
            approved_plan_message_ids: self.approved_plan_message_ids.clone(),
        }
    }

    /// Update metadata from a Session struct (sync UI state back)
    pub fn update_from_session(&mut self, session: &Session) {
        self.name = session.name.clone();
        self.order = session.order;
        self.claude_session_id = session.claude_session_id.clone();
        self.selected_model = session.selected_model.clone();
        self.selected_thinking_level = session.selected_thinking_level.clone();
        self.session_naming_completed = session.session_naming_completed;
        self.archived_at = session.archived_at;
        self.answered_questions = session.answered_questions.clone();
        self.submitted_answers = session.submitted_answers.clone();
        self.fixed_findings = session.fixed_findings.clone();
        self.pending_permission_denials = session.pending_permission_denials.clone();
        self.denied_message_context = session.denied_message_context.clone();
        self.is_reviewing = session.is_reviewing;
        self.waiting_for_input = session.waiting_for_input;
        self.approved_plan_message_ids = session.approved_plan_message_ids.clone();
    }
}

// ============================================================================
// API Response Types (for backward compatibility)
// ============================================================================

/// API response type for session list - built from internal index + metadata
/// This maintains backward compatibility with frontend expectations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorktreeSessions {
    /// Worktree ID for reference
    pub worktree_id: String,
    /// All sessions in this worktree
    pub sessions: Vec<Session>,
    /// ID of the active/displayed session tab
    #[serde(default)]
    pub active_session_id: Option<String>,
    /// Default model for new sessions in this worktree (unused, kept for compatibility)
    #[serde(default)]
    pub default_model: Option<String>,
    /// Storage format version for migrations
    #[serde(default = "default_version")]
    pub version: u32,
    /// Whether branch naming has been attempted for this worktree
    #[serde(default)]
    pub branch_naming_completed: bool,
}

impl Default for WorktreeSessions {
    fn default() -> Self {
        let session = Session::default_session();
        let session_id = session.id.clone();
        Self {
            worktree_id: String::new(),
            sessions: vec![session],
            active_session_id: Some(session_id),
            default_model: None,
            version: 1,
            branch_naming_completed: false,
        }
    }
}

impl WorktreeSessions {
    /// Find a session by ID
    pub fn find_session(&self, session_id: &str) -> Option<&Session> {
        self.sessions.iter().find(|s| s.id == session_id)
    }

    /// Find a session by ID (mutable)
    pub fn find_session_mut(&mut self, session_id: &str) -> Option<&mut Session> {
        self.sessions.iter_mut().find(|s| s.id == session_id)
    }

    /// Get the next session number for naming
    pub fn next_session_number(&self) -> u32 {
        self.sessions.len() as u32 + 1
    }
}

// ============================================================================
// Saved Context Types (for Save/Load Context magic commands)
// ============================================================================

/// Metadata for a saved context file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SavedContext {
    /// Unique ID (UUID)
    pub id: String,
    /// Filename (e.g., "jean-v1-1704067200-implement-magic-commands.md")
    pub filename: String,
    /// Full path to the saved context file
    pub path: String,
    /// Project name this context was saved from
    pub project_name: String,
    /// AI-generated slug from the summary
    pub slug: String,
    /// File size in bytes
    pub size: u64,
    /// Unix timestamp when context was created
    pub created_at: u64,
    /// Optional custom display name (from metadata file)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

/// Metadata for saved contexts (stored in session-context-metadata.json)
/// Maps context filename -> custom name
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SavedContextsMetadata {
    /// Map of filename to custom name
    pub names: HashMap<String, String>,
}

/// Response for listing saved contexts
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SavedContextsResponse {
    pub contexts: Vec<SavedContext>,
}

/// Response from saving a context file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SaveContextResponse {
    /// Unique ID for this context
    pub id: String,
    /// Filename (e.g., "jean-v1-1704067200-implement-magic-commands.md")
    pub filename: String,
    /// Full path to the saved context file
    pub path: String,
    /// File size in bytes
    pub size: u64,
}

// ============================================================================
// All Sessions Types (for loading sessions across all worktrees)
// ============================================================================

/// Entry containing sessions for a single worktree with project/worktree context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllSessionsEntry {
    pub project_id: String,
    pub project_name: String,
    pub worktree_id: String,
    pub worktree_name: String,
    pub worktree_path: String,
    pub sessions: Vec<Session>,
}

/// Response for listing all sessions across all worktrees
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AllSessionsResponse {
    pub entries: Vec<AllSessionsEntry>,
}

// ============================================================================
// Run Types (for NDJSON-based persistence)
// ============================================================================

/// Status of a Claude CLI run
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum RunStatus {
    /// Process is currently active
    Running,
    /// Process completed successfully
    Completed,
    /// User cancelled the run
    Cancelled,
    /// App crashed or process died unexpectedly
    Crashed,
    /// Process still running after app restart (can resume tailing)
    Resumable,
}

/// Metadata for a single Claude CLI execution (stored in manifest)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunEntry {
    /// Unique run identifier (UUID)
    pub run_id: String,
    /// ID of the user message that triggered this run
    pub user_message_id: String,
    /// Content of the user message
    pub user_message: String,
    /// Model used for this run
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,
    /// Execution mode (plan, build, yolo)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub execution_mode: Option<String>,
    /// Thinking level (off, think, megathink, ultrathink)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thinking_level: Option<String>,
    /// Unix timestamp when run started
    pub started_at: u64,
    /// Unix timestamp when run ended (None if still running)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ended_at: Option<u64>,
    /// Current status of the run
    pub status: RunStatus,
    /// ID of the assistant message (generated after completion)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub assistant_message_id: Option<String>,
    /// Whether the run was cancelled by the user
    #[serde(default)]
    pub cancelled: bool,
    /// Whether this run was recovered from a crash
    #[serde(default)]
    pub recovered: bool,
    /// Claude CLI session ID for resuming conversations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claude_session_id: Option<String>,
    /// PID of the detached Claude CLI process (for checking if still running)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pid: Option<u32>,
    /// Token usage for this run (captured from Claude CLI result)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<UsageData>,
}

/// Session metadata - single source of truth for session data and run history
/// Stored in sessions/data/{session_id}/metadata.json
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionMetadata {
    /// Unique session identifier (UUID v4)
    #[serde(alias = "session_id")]
    pub id: String,
    /// Worktree this session belongs to
    pub worktree_id: String,
    /// Display name ("Session 1", or user-customized name)
    #[serde(alias = "session_name")]
    pub name: String,
    /// Order index for tab ordering (0-indexed)
    pub order: u32,
    /// Unix timestamp when session was created
    pub created_at: u64,
    /// Claude CLI session ID for resuming conversations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claude_session_id: Option<String>,
    /// Selected model for this session
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_model: Option<String>,
    /// Selected thinking level for this session
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selected_thinking_level: Option<ThinkingLevel>,
    /// Whether session naming has been attempted
    #[serde(default)]
    pub session_naming_completed: bool,
    /// Unix timestamp when session was archived (None = not archived)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub archived_at: Option<u64>,

    // Session-specific UI state
    /// Tool call IDs that have been answered (for AskUserQuestion)
    #[serde(default)]
    pub answered_questions: Vec<String>,
    /// Submitted answers per tool call: toolCallId -> answers (as JSON)
    #[serde(default)]
    pub submitted_answers: HashMap<String, serde_json::Value>,
    /// Finding keys that have been marked as fixed
    #[serde(default)]
    pub fixed_findings: Vec<String>,
    /// Pending permission denials awaiting user approval
    #[serde(default)]
    pub pending_permission_denials: Vec<PermissionDenial>,
    /// Original message context for re-send after permission approval
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub denied_message_context: Option<DeniedMessageContext>,
    /// Whether this session is marked for review in session board
    #[serde(default)]
    pub is_reviewing: bool,
    /// Whether this session is waiting for user input (AskUserQuestion, ExitPlanMode)
    #[serde(default)]
    pub waiting_for_input: bool,
    /// Message IDs whose plans have been approved
    #[serde(default)]
    pub approved_plan_message_ids: Vec<String>,

    /// Run history - each entry corresponds to one Claude CLI execution
    #[serde(default)]
    pub runs: Vec<RunEntry>,

    /// Storage format version for migrations
    #[serde(default = "default_manifest_version")]
    pub version: u32,
}

fn default_manifest_version() -> u32 {
    1
}

// ============================================================================
// Debug Info Types (for SessionDebugPanel)
// ============================================================================

/// Information about a single JSONL run log file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunLogFileInfo {
    /// Run ID (filename without extension)
    pub run_id: String,
    /// Full path to the JSONL file
    pub path: String,
    /// Status of the run (completed, cancelled, crashed, running)
    pub status: RunStatus,
    /// Preview of the user message that triggered this run
    pub user_message_preview: String,
    /// Token usage for this run (if completed)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usage: Option<UsageData>,
}

/// Debug information about a session's storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionDebugInfo {
    /// App data directory path
    pub app_data_dir: String,
    /// Path to the index JSON file for this worktree
    pub sessions_file: String,
    /// Path to the data directory (contains all session directories)
    pub runs_dir: String,
    /// Path to this session's metadata file (if exists)
    pub manifest_file: Option<String>,
    /// Claude CLI session ID (if any)
    pub claude_session_id: Option<String>,
    /// Path to Claude CLI's JSONL file (in ~/.claude/projects/)
    pub claude_jsonl_file: Option<String>,
    /// List of JSONL run log files for this session
    pub run_log_files: Vec<RunLogFileInfo>,
    /// Total token usage across all runs in this session
    #[serde(default)]
    pub total_usage: UsageData,
}

impl SessionMetadata {
    /// Create a new metadata for a session
    pub fn new(session_id: String, worktree_id: String, session_name: String, order: u32) -> Self {
        Self {
            id: session_id,
            worktree_id,
            name: session_name,
            order,
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            claude_session_id: None,
            selected_model: None,
            selected_thinking_level: None,
            session_naming_completed: false,
            archived_at: None,
            answered_questions: vec![],
            submitted_answers: HashMap::new(),
            fixed_findings: vec![],
            pending_permission_denials: vec![],
            denied_message_context: None,
            is_reviewing: false,
            waiting_for_input: false,
            approved_plan_message_ids: vec![],
            runs: vec![],
            version: 1,
        }
    }

    /// Find a run by ID
    #[allow(dead_code)]
    pub fn find_run(&self, run_id: &str) -> Option<&RunEntry> {
        self.runs.iter().find(|r| r.run_id == run_id)
    }

    /// Find a run by ID (mutable)
    pub fn find_run_mut(&mut self, run_id: &str) -> Option<&mut RunEntry> {
        self.runs.iter_mut().find(|r| r.run_id == run_id)
    }

    /// Get the latest Claude session ID from runs
    #[allow(dead_code)]
    pub fn latest_claude_session_id(&self) -> Option<&str> {
        self.runs
            .iter()
            .rev()
            .find_map(|r| r.claude_session_id.as_deref())
    }

    /// Convert to a lightweight index entry for tab rendering
    pub fn to_index_entry(&self) -> SessionIndexEntry {
        // Count messages: each run has 1 user message, plus 1 assistant message if completed
        let message_count: u32 = self
            .runs
            .iter()
            .map(|run| {
                let is_undo_send =
                    run.status == RunStatus::Cancelled && run.assistant_message_id.is_none();
                if is_undo_send {
                    0
                } else if run.assistant_message_id.is_some() {
                    2 // user + assistant
                } else {
                    1 // just user (still running or cancelled without response)
                }
            })
            .sum();

        SessionIndexEntry {
            id: self.id.clone(),
            name: self.name.clone(),
            order: self.order,
            message_count,
            archived_at: self.archived_at,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================================================
    // ThinkingLevel tests
    // ========================================================================

    #[test]
    fn test_thinking_level_is_enabled() {
        assert!(!ThinkingLevel::Off.is_enabled());
        assert!(ThinkingLevel::Think.is_enabled());
        assert!(ThinkingLevel::Megathink.is_enabled());
        assert!(ThinkingLevel::Ultrathink.is_enabled());
    }

    #[test]
    fn test_thinking_level_tokens() {
        assert_eq!(ThinkingLevel::Off.thinking_tokens(), None);
        assert_eq!(ThinkingLevel::Think.thinking_tokens(), Some(4_000));
        assert_eq!(ThinkingLevel::Megathink.thinking_tokens(), Some(10_000));
        assert_eq!(ThinkingLevel::Ultrathink.thinking_tokens(), Some(31_999));
    }

    #[test]
    fn test_thinking_level_default() {
        let default = ThinkingLevel::default();
        assert_eq!(default, ThinkingLevel::Ultrathink);
    }

    #[test]
    fn test_thinking_level_serialization() {
        assert_eq!(
            serde_json::to_string(&ThinkingLevel::Off).unwrap(),
            "\"off\""
        );
        assert_eq!(
            serde_json::to_string(&ThinkingLevel::Think).unwrap(),
            "\"think\""
        );
        assert_eq!(
            serde_json::to_string(&ThinkingLevel::Megathink).unwrap(),
            "\"megathink\""
        );
        assert_eq!(
            serde_json::to_string(&ThinkingLevel::Ultrathink).unwrap(),
            "\"ultrathink\""
        );
    }

    #[test]
    fn test_thinking_level_deserialization() {
        assert_eq!(
            serde_json::from_str::<ThinkingLevel>("\"off\"").unwrap(),
            ThinkingLevel::Off
        );
        assert_eq!(
            serde_json::from_str::<ThinkingLevel>("\"think\"").unwrap(),
            ThinkingLevel::Think
        );
        assert_eq!(
            serde_json::from_str::<ThinkingLevel>("\"megathink\"").unwrap(),
            ThinkingLevel::Megathink
        );
        assert_eq!(
            serde_json::from_str::<ThinkingLevel>("\"ultrathink\"").unwrap(),
            ThinkingLevel::Ultrathink
        );
    }

    // ========================================================================
    // MessageRole tests
    // ========================================================================

    #[test]
    fn test_message_role_serialization() {
        assert_eq!(
            serde_json::to_string(&MessageRole::User).unwrap(),
            "\"user\""
        );
        assert_eq!(
            serde_json::to_string(&MessageRole::Assistant).unwrap(),
            "\"assistant\""
        );
    }

    // ========================================================================
    // RunStatus tests
    // ========================================================================

    #[test]
    fn test_run_status_serialization() {
        assert_eq!(
            serde_json::to_string(&RunStatus::Running).unwrap(),
            "\"running\""
        );
        assert_eq!(
            serde_json::to_string(&RunStatus::Completed).unwrap(),
            "\"completed\""
        );
        assert_eq!(
            serde_json::to_string(&RunStatus::Cancelled).unwrap(),
            "\"cancelled\""
        );
        assert_eq!(
            serde_json::to_string(&RunStatus::Crashed).unwrap(),
            "\"crashed\""
        );
        assert_eq!(
            serde_json::to_string(&RunStatus::Resumable).unwrap(),
            "\"resumable\""
        );
    }

    // ========================================================================
    // UsageData tests
    // ========================================================================

    #[test]
    fn test_usage_data_default() {
        let usage = UsageData::default();
        assert_eq!(usage.input_tokens, 0);
        assert_eq!(usage.output_tokens, 0);
        assert_eq!(usage.cache_read_input_tokens, 0);
        assert_eq!(usage.cache_creation_input_tokens, 0);
    }

    #[test]
    fn test_usage_data_serialization() {
        let usage = UsageData {
            input_tokens: 100,
            output_tokens: 200,
            cache_read_input_tokens: 50,
            cache_creation_input_tokens: 25,
        };

        let json = serde_json::to_string(&usage).unwrap();
        assert!(json.contains("\"input_tokens\":100"));
        assert!(json.contains("\"output_tokens\":200"));
        assert!(json.contains("\"cache_read_input_tokens\":50"));
    }

    // ========================================================================
    // ContentBlock tests
    // ========================================================================

    #[test]
    fn test_content_block_text_serialization() {
        let block = ContentBlock::Text {
            text: "Hello".to_string(),
        };
        let json = serde_json::to_string(&block).unwrap();
        assert!(json.contains("\"type\":\"text\""));
        assert!(json.contains("\"text\":\"Hello\""));
    }

    #[test]
    fn test_content_block_tool_use_serialization() {
        let block = ContentBlock::ToolUse {
            tool_call_id: "call-123".to_string(),
        };
        let json = serde_json::to_string(&block).unwrap();
        assert!(json.contains("\"type\":\"tool_use\""));
        assert!(json.contains("\"tool_call_id\":\"call-123\""));
    }

    #[test]
    fn test_content_block_thinking_serialization() {
        let block = ContentBlock::Thinking {
            thinking: "Let me analyze...".to_string(),
        };
        let json = serde_json::to_string(&block).unwrap();
        assert!(json.contains("\"type\":\"thinking\""));
        assert!(json.contains("\"thinking\":\"Let me analyze...\""));
    }

    // ========================================================================
    // ChatMessage tests
    // ========================================================================

    #[test]
    fn test_chat_message_default() {
        let msg = ChatMessage::default();
        assert_eq!(msg.id, "");
        assert_eq!(msg.session_id, "");
        assert_eq!(msg.role, MessageRole::User);
        assert_eq!(msg.content, "");
        assert_eq!(msg.timestamp, 0);
        assert!(msg.tool_calls.is_empty());
        assert!(msg.content_blocks.is_empty());
        assert!(!msg.cancelled);
        assert!(!msg.plan_approved);
        assert!(!msg.recovered);
    }

    #[test]
    fn test_chat_message_worktree_id_alias() {
        // Test that worktree_id alias works for backwards compatibility
        let json = r#"{"id":"msg-1","worktree_id":"wt-123","role":"user","content":"test","timestamp":1234567890}"#;
        let msg: ChatMessage = serde_json::from_str(json).unwrap();
        assert_eq!(msg.session_id, "wt-123");
    }

    // ========================================================================
    // ToolCall tests
    // ========================================================================

    #[test]
    fn test_tool_call_serialization() {
        let tool_call = ToolCall {
            id: "call-123".to_string(),
            name: "Read".to_string(),
            input: serde_json::json!({"file_path": "/test.txt"}),
            output: Some("file contents".to_string()),
            parent_tool_use_id: None,
        };

        let json = serde_json::to_string(&tool_call).unwrap();
        assert!(json.contains("\"id\":\"call-123\""));
        assert!(json.contains("\"name\":\"Read\""));
        assert!(json.contains("\"file_path\":\"/test.txt\""));
        assert!(json.contains("\"output\":\"file contents\""));
    }

    #[test]
    fn test_tool_call_with_parent() {
        let tool_call = ToolCall {
            id: "call-456".to_string(),
            name: "Task".to_string(),
            input: serde_json::json!({}),
            output: None,
            parent_tool_use_id: Some("call-123".to_string()),
        };

        let json = serde_json::to_string(&tool_call).unwrap();
        assert!(json.contains("\"parent_tool_use_id\":\"call-123\""));
    }

    // ========================================================================
    // Session tests
    // ========================================================================

    #[test]
    fn test_session_new() {
        let session = Session::new("Test Session".to_string(), 5);
        assert!(!session.id.is_empty()); // UUID should be generated
        assert_eq!(session.name, "Test Session");
        assert_eq!(session.order, 5);
        assert!(session.messages.is_empty());
        assert!(session.claude_session_id.is_none());
        assert!(!session.session_naming_completed);
    }

    #[test]
    fn test_session_default() {
        let session = Session::default_session();
        assert_eq!(session.name, "Session 1");
        assert_eq!(session.order, 0);
    }

    // ========================================================================
    // SessionMetadata tests
    // ========================================================================

    #[test]
    fn test_session_metadata_new() {
        let metadata = SessionMetadata::new(
            "sess-123".to_string(),
            "wt-456".to_string(),
            "Test Session".to_string(),
            0,
        );

        assert_eq!(metadata.id, "sess-123");
        assert_eq!(metadata.worktree_id, "wt-456");
        assert_eq!(metadata.name, "Test Session");
        assert_eq!(metadata.order, 0);
        assert!(metadata.runs.is_empty());
        assert_eq!(metadata.version, 1);
    }

    #[test]
    fn test_session_metadata_find_run() {
        let mut metadata = SessionMetadata::new(
            "sess-123".to_string(),
            "wt-456".to_string(),
            "Test".to_string(),
            0,
        );

        metadata.runs.push(RunEntry {
            run_id: "run-1".to_string(),
            user_message_id: "msg-1".to_string(),
            user_message: "Hello".to_string(),
            model: None,
            execution_mode: None,
            thinking_level: None,
            started_at: 1234567890,
            ended_at: None,
            status: RunStatus::Running,
            assistant_message_id: None,
            cancelled: false,
            recovered: false,
            claude_session_id: None,
            pid: Some(12345),
            usage: None,
        });

        assert!(metadata.find_run("run-1").is_some());
        assert!(metadata.find_run("run-nonexistent").is_none());
    }

    #[test]
    fn test_session_metadata_latest_claude_session_id() {
        let mut metadata = SessionMetadata::new(
            "sess-123".to_string(),
            "wt-456".to_string(),
            "Test".to_string(),
            0,
        );

        // No runs - should be None
        assert!(metadata.latest_claude_session_id().is_none());

        // Add run without claude_session_id
        metadata.runs.push(RunEntry {
            run_id: "run-1".to_string(),
            user_message_id: "msg-1".to_string(),
            user_message: "First".to_string(),
            model: None,
            execution_mode: None,
            thinking_level: None,
            started_at: 1234567890,
            ended_at: None,
            status: RunStatus::Completed,
            assistant_message_id: None,
            cancelled: false,
            recovered: false,
            claude_session_id: None,
            pid: None,
            usage: None,
        });

        assert!(metadata.latest_claude_session_id().is_none());

        // Add run with claude_session_id
        metadata.runs.push(RunEntry {
            run_id: "run-2".to_string(),
            user_message_id: "msg-2".to_string(),
            user_message: "Second".to_string(),
            model: None,
            execution_mode: None,
            thinking_level: None,
            started_at: 1234567891,
            ended_at: None,
            status: RunStatus::Completed,
            assistant_message_id: None,
            cancelled: false,
            recovered: false,
            claude_session_id: Some("claude-sess-abc".to_string()),
            pid: None,
            usage: None,
        });

        assert_eq!(metadata.latest_claude_session_id(), Some("claude-sess-abc"));
    }
}
